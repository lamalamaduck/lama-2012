\documentclass[finnish,11pt]{article}

\usepackage[finnish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{amsfonts,amssymb,amsthm,enumitem}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage{array}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{wasysym}
\usetikzlibrary{arrows,automata,positioning}

\setenumerate{listparindent=\parindent}

\newtheorem*{claim}{Väite}

\newcommand{\set}[1]{{\left\{ #1 \right\}}}
\newcommand{\ceil}[1]{{\left\lceil#1\right\rceil}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\ve}{\varepsilon}

\newenvironment{automata}[1][2.8]%
{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=#1cm,semithick]}%
{\end{tikzpicture}}

\newenvironment{centerautomata}[1][2.8]%
{\begin{center}\begin{automata}[#1]}%
{\end{automata} \end{center}}

\newcommand{\trans}[3]{#1 \to #2 \text{, } #3}

\newcommand{\doubletranss}[2]{%
$\begin{bmatrix}#1 \\ #2 \end{bmatrix}$%
}

\newcommand{\doubletrans}[6]{%
\doubletranss{\trans{#1}{#2}{#3}}{\trans{#4}{#5}{#6}}%
}

\newcommand{\tripletrans}[3]{%
$\begin{bmatrix} #1 \\ #2 \\ #3 \end{bmatrix}$%
}

\newcommand{\spc}{\text{\textvisiblespace}}

\newcolumntype{W}{>{\centering\arraybackslash}m{5cm}}
\newcolumntype{V}{>{\centering\arraybackslash}m{2cm}}

\begin{document}

\subsection*{582206 Laskennan mallit, syksy 2012 \\
  \textmd{9. harjoitusten malliratkaisut \\
    Juhana Laurinharju ja Jani Rahkola}}

\begin{enumerate}
\item
  Esitä tilakaaviona epädeterministinen Turingin kone, joka tunnistaa
  aakkoston $\set{0,1,\#}$ kielen
%
  \begin{equation*}
    \set{\# w_1\# w_2\# \dots \# w_n\# \mid w_i \in \set{0,1}^* \text{
        kaikilla } i \text{ ja } w_i = w_j \text{ joillakin } i \neq j}.
  \end{equation*}

  \begin{centerautomata}
    \node[initial above,state] (qstart)               {$q_{\text{start}}$};
    \node[state]         (q0) [right=of qstart] {$q_0$};
    \node[state]         (q1) [left=of qstart] {$q_1$};
    \node[state]         (q2) [below=of q1] {$q_2$};
    \node[state]         (q3) [below=of q2] {$q_3$};
    \node[state]         (q00) [below left=of q3] {$q_{00}$};
    \node[state]         (q01) [below=of q00] {$q_{01}$};

    \node[state]         (q10) [below right=of q3] {$q_{10}$};
    \node[state]         (q11) [below=of q10] {$q_{11}$};

    \node[state]         (q4) [below right=of q01] {$q_{4}$};
    \node[state]         (q5) [above=of q4] {$q_{5}$};

    \node[state]         (qh0) [right=of q3] {$q_{\#0}$};
    \node[state]         (qh1) [right=of qh0] {$q_{\#1}$};
    \node[accepting,state] (qaccept) [below=of qh1] {$q_{\text{accept}}$};

    \path
    (qstart) edge [bend left]  node {$\# \to R$}                (q0)
    (q0)     edge [loop above] node {$0,1,\# \to R$}            (q0)
    (q0)     edge [bend left]  node {$\spc \to L$}              (qstart)
    (qstart) edge              node {$\# \to S$}                (q1)
    (q1)     edge [loop above] node {$0,1,\# \to L$}            (q1)
    (q1)     edge              node {$\trans{\#}{\bar{\#}}{L}$} (q2)
    (q2)     edge [loop left]  node {$0,1,\# \to L$}            (q2)
    (q2)     edge              node [swap] {$\trans{\#}{\bar{\#}}{R}$} (q3)

    (q3)     edge              node [swap] {$\trans{0}{\bar{0}}{R}$}   (q00)
    (q00)    edge [loop left]  node {$0,1,\# \to R$}            (q00)
    (q00)    edge              node [swap] {$\bar{\#} \to R$}          (q01)
    (q01)    edge [loop left]  node {$\bar{0},\bar{1} \to R$}   (q01)
    (q01)    edge              node [swap] {$\trans{0}{\bar{0}}{L}$}   (q4)

    (q3)     edge              node {$\trans{1}{\bar{1}}{R}$}   (q10)
    (q10)    edge [loop right] node {$0,1,\# \to R$}            (q10)
    (q10)    edge              node {$\bar{\#} \to R$}          (q11)
    (q11)    edge [loop right] node {$\bar{0},\bar{1} \to R$}   (q11)
    (q11)    edge              node {$\trans{1}{\bar{1}}{L}$}   (q4)

    (q4)     edge [loop below] node {$\bar{0},\bar{1} \to L$}   (q4)
    (q4)     edge              node {$\bar{\#} \to L$}          (q5)
    (q5)     edge [loop right] node {$0,1,\# \to L$}            (q5)
    (q5)     edge              node {$\bar{0},\bar{1} \to R$}   (q3)


    (q3)     edge              node {$\# \to R$}                (qh0)
    (qh0)    edge [loop above] node {$0,1,\# \to R$}            (qh0)
    (qh0)    edge              node {$\bar{\#} \to R$}          (qh1)
    (q3)     edge [bend left=60]  node {$\bar{\#} \to R$}          (qh1)
    (qh1)    edge [loop above] node {$\bar{0},\bar{1} \to R$}   (qh1)
    (qh1)    edge              node {$\# \to S$}                (qaccept);
  \end{centerautomata}

\item
  {[Sipser Problem~3.9]} Merkintä $k$-PDA tarkoittaa pinoautomaattia, jossa on
  käytettävänä $k$ pinoa. Siis 0-PDA on NFA ja 1-PDA on tavallinen PDA.
  Osoita, että
%
  \begin{enumerate}
  \item
    \begin{claim}
      2-PDA pystyy tunnistamaan kieliä, joita 1-PDA ei pysty,
    \end{claim}

    2-PDA:lla voidaan tunnistaa kieliä, joita pinoautomaatilla ei, sillä 2-PDA
    on Turing täy\-del\-li\-nen. 2-PDA:lla voidaan siis tunnistaa esimerkiksi
    kieli $\set{a^nb^nc^n \mid n \in \Nat}$ jota pinoautomaatilla ei voida
    tunnistaa.

    2-PDA:n Turing täydellisyys voidaan osoittaa simuloimalla Turingin konetta
    2-PDA:lla:

    \begin{itemize}
    \item
      Simulaatiossa pinon 2 päälimmäinen alkio kuvaa Turigin koneen lukupään
      alla olevaa kohtaa. Jos pinossa 2 ei ole alkioita, on lukupään alla
      tyhjä merkki $\spc$.

    \item
      Merkin korvaaminen tapahtuu ottamalla alkio pinosta 2 ja laittamalla
      korvaava merkki tilalle.

    \item
      Lukupään liikuttaminen vasemmalle tapahtuu ottamalla alkio pinosta 1 ja
      siirtämällä se pinoon 2. Jos pinossa 1 ei ole alkioita, on lukupää
      nauhan alussa, eikä tehdä mitään.

    \item
      Lukupään liikuttaminen oikealle tapahtuu ottamalla alkio pinosta 2 ja
      laittamalla se pinoon 1. Jos pinossa 2 ei ole alkioita, on lukupää
      siirtynyt nauhalla syötteen ohi. Laitetaan tällöin pinoon 1 tyhjä merkki
      $\spc$.
    \end{itemize}

    Simulaatio alkaa lukemalla koko syöte pinoon 1, ja siirtämällä sitten
    lukupäätä vasemalle, kunnes se on syötteen alussa.

  \item
    \begin{claim}
      mutta minkä tahansa 3-PDA:n tunnistama kieli voidaan tunnistaa
      2-PDA:lla.
    \end{claim}

    3-PDA:ta voidaan simuloida nelinauhaisella Turingin koneella. Kolmea
    nauhaa käytetään pinoautomaatin kolmen pinon simulointiin, ja neljännellä
    nauhalla suoritetaan pinoautomaation siirtymiä. Tiedämmä myös, että
    nelinauhaista Turingin konetta voidaan simuloida yksinauhaisella Turigin
    koneella. Yllä olemme osoittaneet, että Turigin konetta voidaan simuloida
    2-PDA:lla. Tämän ketjun kautta voimme siis simuloida 3-PDA:ta 2-PDA:lla.

  \end{enumerate}
%
  \emph{Vihje:} Simuloi Turingin koneen nauhaa kahdella pinolla. Esitä
  ratkaisun periaate pseudokoodilla tms.\ menemättä automaattiformalismin
  yksityiskohtiin.

\item
  {[Sipser Exercise 3.14]} \emph{Jonoautomaatti} on muuten kuin
  pinoautomaatti, mutta pino on korvattu jonolla. Jonoon voidaan kohdistaa
  kahdenlaisia operaatioita:
%
  \begin{itemize}
  \item
    $\textsc{Enqueue}\left(a\right)$ kirjoittaa merkin $a$ jonon loppuun ja
  \item
    \textsc{Dequeue} poistaa jonon ensimmäisen merkin ja palauttaa sen
    arvonaan.
  \end{itemize}

  Pinoautomaatin tapaan syöte on luettavissa merkki kerrallaan. Sovitaan, että
  syötteessä on aina loppumerkkinä (mutta ei muualla) tyhjämerkki $\spc$.
  Turingin koneen tapaan pinoautomaatti hyväksyy syötteen siirtymällä
  erilliseen hyväksyvään tilaan.

  Osoita, että mikä tahansa Turing-tunnistettava kieli voidaan tunnistaa
  deterministisellä jonoautomaatilla. Perusteluksi riittää esittää sopivan
  tasoisena pseudokoodina, miten Turingin konetta voidaan simuloida jonoa
  käyttäen.

  Simulaatiossa haluaisimme esittää Turgin koneen tilan
%
  \begin{align*}
    w_1 \dots w_n q u_1 \dots u_n
    \intertext{jonolla}
    u_1 \dots u_n \$ w_1 \dots w_n
  \end{align*}

  Jonossa merkki $\$$ kuvaa nauhan vasenta reunaa. Lisäksi jos $\$$ merkki on
  jonon ensimmäisenä, tulkitaan se tyhjäksi merkiksi $\spc$.

  Lukupään siirtämiseksi vasemalle tarvitsemme kahden muuttujan verran
  apumuistia. Koska nauha-aakkosto on äärellinen, voidaan nämä apumuuttujat
  koodata jonoautomaatin tiloihin asettamalla tilojen joukoksi $\Gamma \times
  \Gamma \times Q$. Annetaan muuttujille nimet \textsc{head} ja \textsc{tail}
  ja pidetään näissä muuttujissa jonon ensimmäistä ja viimeistä merkkiä.
%
  \begin{align*}
    \intertext{Jono}
    u_1 \dots u_n \$ w_1 \dots w_n
    \intertext{kuvataan nyt siis jonolla ja muuttujien arvoilla}
    \textsc{head} = u_1 \\
    u_2 \dots u_n \$ w_1 \dots w_{n-1} \\
    \textsc{tail} = w_n
  \end{align*}

  Lukupään alla oleva merkki on siis muuttujassa \textsc{head}.

\begin{itemize}
\item
  Lukupään siirtäminen oikealle toimii nyt seuraavasti:
  \begin{enumerate}[label=\arabic*.]
  \item
    Jos $\textsc{head} \neq \$$:
    \begin{enumerate}[label=\arabic*.]
    \item
      $\textsc{enqueue}(\textsc{tail})$
    \item
      $\textsc{tail} = \textsc{head}$
    \item
      $\textsc{head} = \textsc{dequeue}$
    \end{enumerate}
  \item
    Muuten:
    \begin{enumerate}[label=\arabic*.]
    \item
      $\textsc{enqueue}\left(\textsc{tail}\right)$
    \item
      $\textsc{tail} = \spc$
    \end{enumerate}
  \end{enumerate}
%
  \begin{align*}
    \textsc{head} = u_1 &&&& \textsc{head} = u_2 \\
    u_2 \dots u_n \$ w_1 \dots w_{n-1} && \to && u_3 \dots u_n \$ w_1 \dots w_n \\
    \textsc{tail} = w_n &&&& \textsc{tail} = u_1
  \end{align*}
%
  Jos lukupää on siirtynyt syötteen ohi, syötämme vain jonoon tyhjän merkin:
%
  \begin{align*}
    \textsc{head} = \$ &&&& \textsc{head} = \$ \\
    w_1 \dots w_nu_1 \dots u_{n-1} && \to && w_1 \dots w_nu_1 \dots u_n \\
    \textsc{tail} = u_n &&&& \textsc{tail} = \spc
  \end{align*}

\item
  Kun lukupäätä siirretään vasemmalle, merkkaamme jonon viimeisenä olevan
  merkin. Sitten pyö\-ri\-täm\-me jonoa kunnes merkattu merkki on siirtynyt
  jonon alkuun. Silloin jono on oikeassa asennossa ja voimme poistaa
  merkinnän.
%
  \begin{enumerate}[label=\arabic*.]
  \item
    Jos $\textsc{tail} \neq \$$:
    \begin{enumerate}[label=\arabic*.]
    \item
      Merkkaa muuttujassa \textsc{tail} oleva merkki.
    \item
      Kunnes merkattu merkki on muuttujassa \textsc{head}
      \begin{enumerate}[label=\arabic*.]
      \item
        $\textsc{enqueue}(\textsc{tail})$
      \item
        $\textsc{tail} = \textsc{head}$
      \item
        $\textsc{head} = \textsc{dequeue}$
      \end{enumerate}
    \item
      Poista muuttujassa \textsc{head} olevan merkin merkkaus.
    \end{enumerate}
  \end{enumerate}

  Jos lukupää on nauhan vasemmassa reunassa, on jono tilassa
%
  \begin{align*}
    \textsc{head} = w_1 \\
    w_2 \dots w_nu_1 \dots u_n \\
    \textsc{tail} = \$
  \end{align*}
%
  eikä jonoa tarvitse siis käsitellä mitenkään siirrettäessä lukupäätä
  vasemmalle. Tämä on myös tila josta simulaatio alkaa, kun koko syöte on
  ensin luettu jonon.
\end{itemize}

\item
  {[Sipser Problem 3.15]} Näytä että ratkeavien kielten joukko on suljettu
  seuraavien operaatioiden suhteen.
%
  Olkoon $A$ ja $B$ kieliä ja $TM_A$ ja $TM_B$ ne ratkaisevat Turingin koneet.
  \begin{enumerate}
  \item Yhdiste
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Aja $TM_A$ ja $TM_B$ syötteellä $w$.
      \item
        Jos jompi kumpi Turingin koneista hyväksyy, hyväksy. Muuten hylkää.
      \end{enumerate}
    \end{itemize}
  \item Ketjutus
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Jaa merkkijono $w$ epädeterministisesti kahteen osaan $w = w_1w_2$.
      \item
        Aja $TM_A$ syötteellä $w_1$ ja $TM_B$ syötteellä $w_2$.
      \item
        Jos molemmat Turingin koneet hyväksyvät hyväksy. Muuten hylkää.
      \end{enumerate}
    \end{itemize}
  \item Tähti
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Jaa merkkijono $w$ epädeterministisesti $n$ osaan $w = w_1 \cdots
        w_n$.
      \item
        Aja $TM_A$ jokaisella osalla $w_i, i \in \set{1, \dots, n}$.
      \item
        Jos jokainen ajo hyväksyy, hyväksy. Muuten hylkää.
      \end{enumerate}
    \end{itemize}
  \item Komplementti
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Aja $TM_A$ syötteellä $w$.
      \item
        Jos ajo hyväksyy, hylkää, jos ajo hylkää, hyväksy.
      \end{enumerate}
    \end{itemize}
  \item Leikkaus
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Aja $TM_A$ ja $TM_B$ syötteellä $w$.
      \item
        Jos molemmat Turingin koneista hyväksyvät, hyväksy. Muuten hylkää.
      \end{enumerate}
    \end{itemize}
  \end{enumerate}

\item
  {[Sipser Problem 3.16]} Näytä että Turin-tunnistettavien kielten joukko on
  suljettu seuraavien operaatioiden suhteen.

  Tunnistaminen eroaa näiden operaatioiden osalta vain yhdisteen tapauksessa.
%
  \begin{enumerate}
  \item Yhdiste
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Aja $TM_A$ ja $TM_B$ syötteellä $w$ siten, että molempia Turingin
        koneita suoritetaan yksi tilasiirtymä kerrallaan.
      \item
        Jos jompi kumpi Turingin koneista hyväksyy, hyväksy.
      \end{enumerate}
    \end{itemize}

    Toinen vaihtoehto on käyttää epädeterministisyyttä.

    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Valitse epädeterministisesti toinen Turingin koneista $TM_A$ ja
        $TM_B$. Aja valittua konetta syötteellä $w$.
      \item
        Jos ajettava Turingin kone hyväksyy, hyväksy.
      \end{enumerate}
    \end{itemize}
  \item Ketjutus
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Jaa merkkijono $w$ epädeterministisesti kahteen osaan $w = w_1w_2$.
      \item
        Aja $TM_A$ syötteellä $w_1$ ja $TM_B$ syötteellä $w_2$.
      \item
        Jos molemmat Turingin koneet hyväksyvät hyväksy.
      \end{enumerate}
    \end{itemize}
  \item Tähti
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Jaa merkkijono $w$ epädeterministisesti $n$ osaan $w = w_1 \cdots
        w_n$.
      \item
        Aja $TM_A$ jokaisella osalla $w_i, i \in \set{1, \dots, n}$.
      \item
        Jos jokainen ajo hyväksyy, hyväksy.
      \end{enumerate}
    \end{itemize}
  \item Leikkaus
    \begin{itemize}
    \item
      Syötteellä $w$:
      \begin{enumerate}[label=\arabic*.]
      \item
        Aja $TM_A$ ja $TM_B$ syötteellä $w$.
      \item
        Jos molemmat Turingin koneista hyväksyvät, hyväksy.
      \end{enumerate}
    \end{itemize}
  \end{enumerate}
\end{enumerate}

\end{document}
